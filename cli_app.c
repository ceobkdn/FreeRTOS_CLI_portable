/*
 * FreeRTOS+CLI V1.0.4
 * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */



/* Utils includes. */
#include "cli_app.h"


/*-----------------------------------------------------------*/
BaseType_t prvClcCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
  ( void ) pcCommandString;
  static int index = 0;

  if ( index < 5 )
  {
    /* Return the clear command help string */
    memset( pcWriteBuffer, 0x00, xWriteBufferLen );
    //strncpy( pcWriteBuffer, "\e[1;1H\e[2J", xWriteBufferLen );
    
    //strncpy( pcWriteBuffer, "This is clear command", xWriteBufferLen );
    //strcat(strcpy(pcWriteBuffer, "This is clear command"), "1");
    
    sprintf(pcWriteBuffer, "This is %d \r\n", index);
    index++ ;
    return pdTRUE;
  }
  else
  {
    index = 0;
    sprintf(pcWriteBuffer, "This is the end");
    return pdFALSE;
  }
  return pdFALSE;
}

/*-----------------------------------------------------------*/

void FreeRTOS_CLI_Put(char InChar, void ( *printFunc )( char [] ))
 {
    static char cInputString[ cmdMAX_INPUT_SIZE ], cOutputString[ cmdMAX_OUTPUT_SIZE ];
    static char cInChar, cInputIndex = 0;
    BaseType_t xMoreDataToFollow;
      /* Newline characters are taken as the end of the command
      string. */
      cInChar = InChar;
      
      if( cInChar == '\n' )
      {
        /* Process the input string received prior to the
        newline. */
        do
        {
          /* Pass the string to FreeRTOS+CLI. */
          xMoreDataToFollow = FreeRTOS_CLIProcessCommand( cInputString, cOutputString, cmdMAX_OUTPUT_SIZE );
    
          /* Send the output generated by the command's
          implementation. */
          (*printFunc)(cOutputString);
    
        } while( xMoreDataToFollow != pdFALSE ); /* Until the command does not generate any more output. */
    
        /* All the strings generated by the command processing
        have been sent.  Clear the input string ready to receive
        the next command. */
        cInputIndex = 0;
        memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
    
      }
      else
      {
        if( cInChar == '\r' )
        {
          /* Ignore the character.  Newlines are used to
          detect the end of the input string. */
        }
        else if( cInChar == '\b' )
        {
          /* Backspace was pressed.  Erase the last character
          in the string - if any. */
          if( cInputIndex > 0 )
          {
            cInputIndex--;
            cInputString[ cInputIndex ] = '\0';
          }
        }
        else
        {
          /* A character was entered.  Add it to the string
          entered so far.  When a \n is entered the complete
          string will be passed to the command interpreter. */
          if( cInputIndex < cmdMAX_INPUT_SIZE )
          {
            cInputString[ cInputIndex ] = cInChar;
            cInputIndex++;
          }
        }
      }
 }
 
